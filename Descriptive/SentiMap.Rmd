---
title: "SentiMap"
author: "HU WEI"
date: "1 March 2018"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Import Data

First of all, we can import the data.

```{r}
rm(list=ls())
t2<-read.csv("twitter_file_with_text.csv",fill=T, sep=",", stringsAsFactors = FALSE)
names(t2)
```

We can see that there are **51** variables in this dataset.

```{r}
attach(t2)
Size<-dim(t2)
Size
```

There are **2491** observations.

## Classes of variables

Get the class of each variable in dataset.

```{r}
lapply(t2, class)
```

We are interested in numeric variables as follow:

* sentiment
* followers_count
* statuses_count
* friends_count
* favourites_count
* listed_count

## Descriptive statistics

### Sentiment

```{r}
summary(sentiment)
table(sentiment)
hist(sentiment, freq=F, main="Sentiment Histogram", breaks=seq(from=-12.5,to=9.5,by=1), col=c(2,3), xlab="Sentiment")
# Add the line of density, "col" for color, "lwd" for line width
lines(density(sentiment),col=2,lwd=3)

sum(sentiment==0)/Size[1]
```

There are **20** level of sentiment and most of them are **neutral** (78.28%).

### Followers count

```{r}
summary(followers_count)
quantile(followers_count)
```

We can find that the range of follower_count is really large. Thus we can analyze the logrithmic value of follower_count.

```{r}
followers_count2<-log(followers_count[followers_count!=0])
summary(followers_count2)
quantile(followers_count2)
```

The result is better. Then we can use the excellent fitdistrplus package which offers some nice functions for distribution fitting. We will use the functiondescdist to gain some ideas about possible candidate distributions.

```{r}
#install.packages("fitdistrplus")
library(fitdistrplus)
#install.packages("logspline")
library(logspline)
descdist(followers_count2, discrete = FALSE)
```


```{r}
hist(followers_count2, freq=F, main="Sentiment Histogram", breaks=seq(from=0,to=15,by=1), col=c(2,3), xlab="log(#Follower)")
# Add the line of density, "col" for color, "lwd" for line width
lines(density(followers_count2),col=2,lwd=3)

fit.norm <- fitdist(followers_count2, "norm")
plot(fit.norm)
```

Percentage of followers number that exceeds 1000

```{r}
sum(followers_count>1000)/Size[1]
```

Percentage of followers number that exceeds 5000

```{r}
sum(followers_count>5000)/Size[1]
```

## Statuses Count

```{r}
summary(statuses_count)
summary(friends_count)
summary(favourites_count)
summary(listed_count)
```



```{r}
sum(lang=="en")/Size[1]

sum(geo_enabled == "True")/Size[1]

sum(location[lang=="en"]=="")/Size[1]
```


## Time Zone

### Get geographical data

```{r}
# Check version of R, becasue ggmap require R version higher than 3.4.3
#R.Version()
#install.packages("ggmap")
library(ggmap)
#install.packages("tidyverse")
#library(tidyverse)
# Check the version info of ggmap
#sessionInfo()
```

Read the georaphical data from `geocoded.csv`.

```{r}
geocoded<-read.csv("geocoded.csv",fill=T, sep=",", stringsAsFactors = FALSE)
```

### Plot Map

```{r}
#install.packages("rworldmap")
library(rworldmap)
newmap <- getMap(resolution = "low")
plot(newmap, asp = 1)
points(geocoded$lon, geocoded$lat, col = "red", cex = .6)
```
